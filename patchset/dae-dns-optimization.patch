diff --git a/control/dns.go b/control/dns.go
index 5d9818e..e2d3e53 100644
--- a/control/dns.go
+++ b/control/dns.go
@@ -353,6 +353,10 @@ func (d *DoUDP) ForwardDNS(ctx context.Context, data []byte) (*dnsmessage.Msg, e
 	if err != nil {
 		return nil, err
 	}
+	// UDP包大小限制，超出4096直接丢弃
+	if n > 4096 {
+		return nil, fmt.Errorf("UDP DNS response too large: %d bytes (limit 4096)", n)
+	}
 	var msg dnsmessage.Msg
 	if err = msg.Unpack(respBuf[:n]); err != nil {
 		return nil, err
diff --git a/control/dns_control.go b/control/dns_control.go
index 6a55368..8356b76 100644
--- a/control/dns_control.go
+++ b/control/dns_control.go
@@ -8,6 +8,7 @@ package control
 import (
 	"context"
 	"fmt"
+	"hash/fnv"
 	"math"
 	"net"
 	"net/netip"
@@ -26,11 +27,18 @@ import (
 	dnsmessage "github.com/miekg/dns"
 	"github.com/mohae/deepcopy"
 	"github.com/sirupsen/logrus"
+	"golang.org/x/sync/singleflight"
 )
 
 const (
 	MaxDnsLookupDepth  = 3
 	minFirefoxCacheTtl = 120
+	// 缓存分片数，减少锁竞争
+	dnsCacheShards = 16
+	// 全局并发查询限制
+	maxGlobalConcurrentQueries = 2000
+	// DNS缓存最小TTL，防止频繁查询
+	minDnsTtlSeconds = 60
 )
 
 type IpVersionPrefer int
@@ -62,7 +70,10 @@ type DnsControllerOption struct {
 }
 
 type DnsController struct {
-	handling sync.Map
+	sfg singleflight.Group // singleflight用于合并同key查询
+
+	// 全局并发控制
+	globalConcurrentQueries int64
 
 	routing     *dns.Dns
 	qtypePrefer uint16
@@ -76,16 +87,15 @@ type DnsController struct {
 	timeoutExceedCallback func(dialArgument *dialArgument, err error)
 
 	fixedDomainTtl map[string]int
-	// mutex protects the dnsCache.
-	dnsCacheMu          sync.Mutex
-	dnsCache            map[string]*DnsCache
+	// 分片缓存，减少锁竞争
+	dnsCacheShards      [dnsCacheShards]dnsCacheShard
 	dnsForwarderCacheMu sync.Mutex
 	dnsForwarderCache   map[dnsForwarderKey]DnsForwarder
 }
 
-type handlingState struct {
-	mu  sync.Mutex
-	ref uint32
+type dnsCacheShard struct {
+	mu    sync.RWMutex
+	cache map[string]*DnsCache
 }
 
 func parseIpVersionPreference(prefer int) (uint16, error) {
@@ -108,7 +118,7 @@ func NewDnsController(routing *dns.Dns, option *DnsControllerOption) (c *DnsCont
 		return nil, err
 	}
 
-	return &DnsController{
+	controller := &DnsController{
 		routing:     routing,
 		qtypePrefer: prefer,
 
@@ -120,11 +130,16 @@ func NewDnsController(routing *dns.Dns, option *DnsControllerOption) (c *DnsCont
 		timeoutExceedCallback: option.TimeoutExceedCallback,
 
 		fixedDomainTtl:      option.FixedDomainTtl,
-		dnsCacheMu:          sync.Mutex{},
-		dnsCache:            make(map[string]*DnsCache),
 		dnsForwarderCacheMu: sync.Mutex{},
 		dnsForwarderCache:   make(map[dnsForwarderKey]DnsForwarder),
-	}, nil
+	}
+
+	// 初始化分片缓存
+	for i := 0; i < dnsCacheShards; i++ {
+		controller.dnsCacheShards[i].cache = make(map[string]*DnsCache)
+	}
+
+	return controller, nil
 }
 
 func (c *DnsController) cacheKey(qname string, qtype uint16) string {
@@ -133,17 +148,16 @@ func (c *DnsController) cacheKey(qname string, qtype uint16) string {
 }
 
 func (c *DnsController) RemoveDnsRespCache(cacheKey string) {
-	c.dnsCacheMu.Lock()
-	_, ok := c.dnsCache[cacheKey]
-	if ok {
-		delete(c.dnsCache, cacheKey)
-	}
-	c.dnsCacheMu.Unlock()
+	shard := c.getDnsCacheShard(cacheKey)
+	shard.mu.Lock()
+	delete(shard.cache, cacheKey)
+	shard.mu.Unlock()
 }
 func (c *DnsController) LookupDnsRespCache(cacheKey string, ignoreFixedTtl bool) (cache *DnsCache) {
-	c.dnsCacheMu.Lock()
-	cache, ok := c.dnsCache[cacheKey]
-	c.dnsCacheMu.Unlock()
+	shard := c.getDnsCacheShard(cacheKey)
+	shard.mu.RLock()
+	cache, ok := shard.cache[cacheKey]
+	shard.mu.RUnlock()
 	if !ok {
 		return nil
 	}
@@ -287,21 +301,22 @@ func (c *DnsController) __updateDnsCacheDeadline(host string, dnsTyp uint16, ans
 	deadline, originalDeadline := deadlineFunc(now, host)
 
 	cacheKey := c.cacheKey(fqdn, dnsTyp)
-	c.dnsCacheMu.Lock()
-	cache, ok := c.dnsCache[cacheKey]
+	shard := c.getDnsCacheShard(cacheKey)
+	shard.mu.Lock()
+	cache, ok := shard.cache[cacheKey]
 	if ok {
 		cache.Answer = answers
 		cache.Deadline = deadline
 		cache.OriginalDeadline = originalDeadline
-		c.dnsCacheMu.Unlock()
+		shard.mu.Unlock()
 	} else {
 		cache, err = c.newCache(fqdn, answers, deadline, originalDeadline)
 		if err != nil {
-			c.dnsCacheMu.Unlock()
+			shard.mu.Unlock()
 			return err
 		}
-		c.dnsCache[cacheKey] = cache
-		c.dnsCacheMu.Unlock()
+		shard.cache[cacheKey] = cache
+		shard.mu.Unlock()
 	}
 	if err = c.cacheAccessCallback(cache); err != nil {
 		return err
@@ -324,9 +339,25 @@ func (c *DnsController) UpdateDnsCacheDeadline(host string, dnsTyp uint16, answe
 }
 
 func (c *DnsController) UpdateDnsCacheTtl(host string, dnsTyp uint16, answers []dnsmessage.RR, ttl int) (err error) {
+	// 设置最小TTL为60秒，防止频繁查询
+	if ttl < minDnsTtlSeconds {
+		ttl = minDnsTtlSeconds
+		if c.log.IsLevelEnabled(logrus.DebugLevel) {
+			c.log.Debugf("DNS TTL for %s too small, adjusted to %d seconds", host, minDnsTtlSeconds)
+		}
+	}
+
 	return c.__updateDnsCacheDeadline(host, dnsTyp, answers, func(now time.Time, host string) (daedline time.Time, originalDeadline time.Time) {
 		originalDeadline = now.Add(time.Duration(ttl) * time.Second)
 		if fixedTtl, ok := c.fixedDomainTtl[host]; ok {
+			if fixedTtl == 0 {
+				// TTL为0表示不缓存，立即过期
+				return now.Add(-1 * time.Second), originalDeadline
+			}
+			// 固定TTL也要遵循最小60秒限制（除非是0）
+			if fixedTtl < minDnsTtlSeconds {
+				fixedTtl = minDnsTtlSeconds
+			}
 			return now.Add(time.Duration(fixedTtl) * time.Second), originalDeadline
 		} else {
 			return originalDeadline, originalDeadline
@@ -444,66 +475,122 @@ func (c *DnsController) handle_(
 		qtype = q.Qtype
 	}
 
-	// Route request.
+	cacheKey := c.cacheKey(qname, qtype)
+
+	// 检查是否为禁用缓存的域名（fixed_domain_ttl=0）
+	host := strings.TrimSuffix(qname, ".")
+	if fixedTtl, ok := c.fixedDomainTtl[host]; ok && fixedTtl == 0 {
+		// TTL为0表示禁用缓存，直接跳过缓存查找
+		if c.log.IsLevelEnabled(logrus.DebugLevel) {
+			c.log.Debugf("DNS cache disabled for %s (fixed_domain_ttl=0), skipping cache lookup", host)
+		}
+	} else {
+		// 优先查缓存 - 缓存命中直接返回，跳过所有规则匹配和路由处理
+		if resp := c.LookupDnsRespCache_(dnsMessage, cacheKey, false); resp != nil {
+			if needResp {
+				if err = sendPkt(c.log, resp, req.realDst, req.realSrc, req.src, req.lConn); err != nil {
+					return fmt.Errorf("failed to write cached DNS resp: %w", err)
+				}
+			}
+			if c.log.IsLevelEnabled(logrus.DebugLevel) && len(dnsMessage.Question) > 0 {
+				q := dnsMessage.Question[0]
+				c.log.Debugf("UDP(DNS) %v <-> Cache: %v %v",
+					RefineSourceToShow(req.realSrc, req.realDst.Addr()), strings.ToLower(q.Name), QtypeToString(q.Qtype),
+				)
+			}
+			return nil
+		}
+	}
+
+	// 缓存未命中，进行路由规则匹配
 	upstreamIndex, upstream, err := c.routing.RequestSelect(qname, qtype)
 	if err != nil {
 		return err
 	}
 
-	cacheKey := c.cacheKey(qname, qtype)
-
 	if upstreamIndex == consts.DnsRequestOutboundIndex_Reject {
-		// Reject with empty answer.
 		c.RemoveDnsRespCache(cacheKey)
 		return c.sendReject_(dnsMessage, req)
 	}
 
-	// No parallel for the same lookup.
-	handlingState_, _ := c.handling.LoadOrStore(cacheKey, new(handlingState))
-	handlingState := handlingState_.(*handlingState)
-	atomic.AddUint32(&handlingState.ref, 1)
-	handlingState.mu.Lock()
-	defer func() {
-		handlingState.mu.Unlock()
-		atomic.AddUint32(&handlingState.ref, ^uint32(0))
-		if atomic.LoadUint32(&handlingState.ref) == 0 {
-			c.handling.Delete(cacheKey)
+	// 全局并发控制，防止资源耗尽
+	current := atomic.LoadInt64(&c.globalConcurrentQueries)
+	if current >= maxGlobalConcurrentQueries {
+		if c.log != nil {
+			c.log.Warnf("Global concurrent DNS queries limit reached (%d), dropping %s", current, cacheKey)
 		}
-	}()
+		return fmt.Errorf("too many global concurrent DNS queries (%d), dropping %s", current, cacheKey)
+	}
+	atomic.AddInt64(&c.globalConcurrentQueries, 1)
+	defer atomic.AddInt64(&c.globalConcurrentQueries, -1)
+
+	// singleflight合并同key查询，带超时保护
+	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
+	defer cancel()
+
+	type result struct {
+		data []byte
+		err  error
+	}
 
-	if resp := c.LookupDnsRespCache_(dnsMessage, cacheKey, false); resp != nil {
-		// Send cache to client directly.
-		if needResp {
-			if err = sendPkt(c.log, resp, req.realDst, req.realSrc, req.src, req.lConn); err != nil {
-				return fmt.Errorf("failed to write cached DNS resp: %w", err)
+	resultCh := make(chan result, 1)
+	go func() {
+		v, err, _ := c.sfg.Do(cacheKey, func() (interface{}, error) {
+			// panic保护
+			defer func() {
+				if r := recover(); r != nil {
+					if c.log != nil {
+						c.log.Errorf("panic in singleflight DNS query for %s: %v", cacheKey, r)
+					}
+				}
+			}()
+
+			if c.log.IsLevelEnabled(logrus.DebugLevel) {
+				c.log.Debugf("singleflight: real upstream query for %s", cacheKey)
 			}
+
+			// Re-pack DNS packet.
+			data, err := dnsMessage.Pack()
+			if err != nil {
+				return nil, fmt.Errorf("pack DNS packet: %w", err)
+			}
+
+			err = c.dialSend(0, req, data, dnsMessage.Id, upstream, false)
+			if err != nil {
+				return nil, err
+			}
+
+			// 查询后获取缓存结果
+			resp := c.LookupDnsRespCache_(dnsMessage, cacheKey, false)
+			return resp, nil
+		})
+		if v != nil {
+			resultCh <- result{data: v.([]byte), err: err}
+		} else {
+			resultCh <- result{data: nil, err: err}
 		}
-		if c.log.IsLevelEnabled(logrus.DebugLevel) && len(dnsMessage.Question) > 0 {
-			q := dnsMessage.Question[0]
-			c.log.Debugf("UDP(DNS) %v <-> Cache: %v %v",
-				RefineSourceToShow(req.realSrc, req.realDst.Addr()), strings.ToLower(q.Name), QtypeToString(q.Qtype),
-			)
-		}
-		return nil
-	}
+	}()
 
-	if c.log.IsLevelEnabled(logrus.TraceLevel) {
-		upstreamName := upstreamIndex.String()
-		if upstream != nil {
-			upstreamName = upstream.String()
+	var v []byte
+	select {
+	case res := <-resultCh:
+		v = res.data
+		err = res.err
+	case <-ctx.Done():
+		if c.log != nil {
+			c.log.Warnf("DNS upstream query timeout for %s", cacheKey)
 		}
-		c.log.WithFields(logrus.Fields{
-			"question": dnsMessage.Question,
-			"upstream": upstreamName,
-		}).Traceln("Request to DNS upstream")
+		return fmt.Errorf("DNS upstream query timeout for %s", cacheKey)
 	}
-
-	// Re-pack DNS packet.
-	data, err := dnsMessage.Pack()
 	if err != nil {
-		return fmt.Errorf("pack DNS packet: %w", err)
+		return err
 	}
-	return c.dialSend(0, req, data, dnsMessage.Id, upstream, needResp)
+	if needResp && v != nil {
+		if err = sendPkt(c.log, v, req.realDst, req.realSrc, req.src, req.lConn); err != nil {
+			return fmt.Errorf("failed to write singleflight DNS resp: %w", err)
+		}
+	}
+	return nil
 }
 
 // sendReject_ send empty answer.
@@ -691,3 +778,15 @@ func (c *DnsController) dialSend(invokingDepth int, req *udpRequest, data []byte
 	}
 	return nil
 }
+
+// 计算缓存分片索引
+func (c *DnsController) getShardIndex(key string) int {
+	h := fnv.New32a()
+	h.Write([]byte(key))
+	return int(h.Sum32() % dnsCacheShards)
+}
+
+// 分片式缓存操作，减少锁竞争
+func (c *DnsController) getDnsCacheShard(key string) *dnsCacheShard {
+	return &c.dnsCacheShards[c.getShardIndex(key)]
+}
